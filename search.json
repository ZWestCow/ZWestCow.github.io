[{"title":"拓展欧几里得","url":"/拓展欧几里得.html","content":"\n拓展欧几里得是基于欧几里得算法的，在数论中算比较基础的一块了，那么今天就来讲一讲它。\n\n<!-- more -->\n\n## 前置技能\n\n---\n\n1. 欧几里得算法\n\n   就是GCD，辗转相除法求最大公约数，数论中没有比这个更简单的了。很多人都会想到，就像高斯消元一样，这么叫不过是因为他们出生比较早，当然，死的也比较早。\n\n   如果还有不懂，自行百度。\n\n2. 裴蜀定理\n\n   裴蜀定理是一个关于最大公约数的定理，说明了对任何整数a、b和它们的最大公约数d，关于未知数x和y的线性丢番图方程~~看不懂就当我没说~~，大概意思如下：\n\n   > ax + by = m \n\n   有解当且仅当m是d的倍数 （d为a、b最大公约数总看得懂了吧）\n\n## 基本事实\n\n---\n\n### 所求\n\n拓展欧几里得求的是：已知 ` ax + by = m ` ，求一组整数解(x,y)（a,b,c均为整数 ）。\n\n### 简化\n\n由裴蜀定理可得：令 `ax + by = m `简化为 `ax + by = c ` (反正m为c倍数)。\n\n还可以得到另外一个结论，也挺有用 ：`ax + by = 1`有整数解当且仅当GCD(a,b)=1（即a与b互质） \n\n## 推导求解\n\n---\n\n1.  对(a,b)做辗转相除法直到(c,0) ~~很显然，不是吗~~\n2. ​ 由于c + 0 = c，可以得到此时必有一解(x,y) = (1,0) （事实上y是任意的，只不过为了防止造数据的无脑...你懂的）\n3. 假设现在我们已知`bx0 + (a mod b)y0 = c`，如何求出ax + by = c的解？（为什么要这么写？参考GCD的过程） \n4. 因为`a mod b`比较难操作，所以要先将上式改写为`bx0 + (a – [a/b] * b)y0 = c`(形如`a mod b`的式子，一般来说在推导过程中都要化为`a – [a/b] * b `)\n5. 在做GCD时递归即可\n\n## 上代码\n\n---\n\n```c++\n#include<cstdio>\nusing namespace std;\nint a,b;\nstruct ANS{\n\tint x,y;\n}ans;\nvoid gcd(int x,int y){\n\tif(!y) {ans.x=1;ans.y=0;}\n\telse{\n\t\tgcd(y,x%y);\n\t\tint t=ans.x;\n\t\tans.x=ans.y;\n\t\tans.y=t-((int)(x/y))*ans.y;\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&a,&b);\n\tgcd(a,b);\n\tprintf(\"%d %d\\n\",ans.x,ans.y);\n\treturn 0;\n}\n```\n\n顺便给一个Python版的代码\n\n```python\nclass ANS:\n    x=0\n    y=0\n    def __init__(self):\n        self.x=0\n        self.y=0\n\n\ndef gcd(x,y):\n    global ans\n    if not y:\n        ans.x=1\n        ans.y=0\n    else:\n        gcd(y,x%y)\n        t=ans.x\n        ans.x=ans.y\n        ans.y=t-(int(x/y))*ans.y\n\n\nans=ANS()\na=0\nb=0\na,b = [int(j) for j in raw_input().split()]\ngcd(a,b)\nprint str(ans.x)+' '+str(ans.y)\n\n```\n\n","tags":["数论"],"categories":["数论"]},{"title":"求任意多边形面积","url":"/求任意多边形面积.html","content":"其实求多边形面积有许多的方法，这里介绍一个计算几何的方法，比较神奇，只有O(n)的复杂度。\n\n<!-- more -->\n\n说道计算几何中的神奇方法，就不得不说到向量（又叫矢量，不过这个名词有歧义）。\n\n## 向量（大佬跳过）\n\n---\n\n其实，像这种概念问题，大家都可以去问一下~~我~~度娘，还挺详细的。\n\n### 简介\n\n数学中的向量只有两个值，一个方向，一个大小，于是不论怎么平移，它不会有任何改变。不过，这样子表示向量的话，它的用处就太小了。但是，当我们让向量都从一点出发的话，它的意义就很多了，能够做一些奇奇怪怪的事情。所以在计算机算法里，其中有这样一个表示向量的方法：一般都默认一个向量是从原点出发的，把它另一个端点的坐标记下来。\n\n向量有几个基本运算：加、减、点积、叉积。关于其数学计算方法（计算机中次要）以及几何意义（非常重要），大家请自行去百度吧。\n\n接下来会简单介绍一下以上述记录向量的方法进行基本运算\n\n### 加减法\n\n加减其实特简单，了解一下基本性质之后（或者百度向量后，看一下加减法的图示，这里就懒一点，不搬运了），特别好推，绝对秒出公式。\n\n### 点积\n\n两个向量的叉积只会返回一个值，而不是一个向量。其几何意义差不多是下面这样 ,有一个向量 $\\vec{a}$ 为BC，还有一个向量 $\\vec{b}$为BC。那么，$\\vec{a}$与点积$\\vec{b}$为$S\\Delta ABCD$ ,就是$Ax\\cdot By-Ay\\cdot Bx$，（注意，不符合交换律）\n\n![](http://t1.aixinxi.net/o_1cgjlenojg4n1hue14t4la0k2qa.png-w.jpg)\n\n\n\n### 叉积\n\n叉积返回值是一个向量，大小为点积，方向符合右手螺旋定理，垂直于另外两向量，也就是说叉积运算是三维中的概念（不符合交换律） \n\n## 计算面积\n\n---\n\n### 思路\n\n比如下面这个：\n\n![](http://t1.aixinxi.net/o_1cgjm939p1hfdbubgqu88217iva.png-w.jpg)\n\n相信一些眼尖的读者已经发现了，这个多边形上的点都连了一条到原点的线段，相邻两点间的连线与两点和原点的连线构成了8个三角形（多边形共八条线段），如果把其中一些三角形的面积加起来，再减掉另一些三角形的面积，就是所求多边形的面积！而且与原点位置什么都无关！\n\n所以我们只要判断哪些三角形加上，哪些三角形减去即可！至于怎么判断，相信我，向量会自动帮你做这件事。\n\n下面上代码\n\n### 代码\n\n先上个C++的吧\n\n```C++\n//输入必须是将点按顺序输入，顺时还是逆时程序会处理的 \n#include<cstdio>\nusing namespace std;\ndouble ans;\nint n;\nstruct Point{\n\tint x,y;\n}a[1000000];\nint read(){\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn ret*f;\n}\nint main(){\n\tn=read();//共n个点 \n\tfor(int i=1;i<=n;i++) a[i]=(Point){read(),read()};\n\tfor(int i=2;i<=n;i++)\n\t\tans+=(double)(a[i].x*a[i-1].y-a[i].y*a[i-1].x)/*记得求平行四边形面积公式吗*//2.0;\n\t\t//求三角形面积。全加起来就好了，因为...面积有方向（正负性），自己会消掉的 \n\tans+=(double)(a[1].x*a[n].y-a[1].y*a[n].x)/2.0;//第1和第n个点单独处理 \n\tif(ans<0.0) ans=-ans;//顺时针与逆时针输入结果互为相反数 \n\tprintf(\"%lf\",ans);\n\treturn 0;\n} \n```\n\n好长时间没写Python了，几乎忘光了，没事干就写了一个Python版的代码（可能非常啰嗦），就不挂注释了。\n\n```python\nx=[1]\ny=[1]\nans=0\nn=0\nn=input()\nfor i in range(1,n+1):\n    x.append(0)\n    y.append(0)\n    x[i],y[i] = [int(j) for j in raw_input().split()]\nfor i in range(2,n+1):\n    ans=ans+(float)(x[i]*y[i-1]-x[i-1]*y[i])/2.0\nans=ans+(float)(x[1]*y[n]-x[n]*y[1])/2.0\nif ans<0:\n    ans=-ans\nprint ans\n\n```","tags":["计算几何"],"categories":["计算几何"]},{"title":"用Hexo搭建自己的网站-添加主题","url":"/用hexo搭建自己的网站-添加主题.html","content":"\n 如标题所述\n\n<!-- more -->\n\nhexo是一个平台，有许多人为其开发了主题，若想要换主题，可以直接去官网https://hexo.io/themes/找合适的主题。\n\n这些主题基本上都是链接在github的开源项目，所以你可能需要先注册一个GitHub账户。\n\n至于具体操作，每个主题都不一样，功能也不尽相同，安装方法也略有区别，不过开发者应该都配备有详细介绍，大伙自个儿钻研吧（跑）\n\n另外如果看到了某位大佬（先声明，绝对不包括我）的博客，觉得好，想要模（zhan）仿（wei）一（ji）个（you），可以关注一下这个博客的右下角，基本上可以找到这个主题名字，还有GitHub贮存库的链接。","tags":["博客"],"categories":["blog"]},{"title":"高效的单字符串匹配算法Horspool","url":"/高效的单字符串匹配算法Horspool.html","content":"\n在单字符串匹配算法的领域中，有两种为人熟知的算法：KMP（~~看毛片~~）和BM算法，这两种算法虽然经典，不过难码。实际上许多简单的算法速度也是飞快。于是就让我们来认识一下BM的简化版——Horspool，效率比KMP、BM都快，还好理解。\n\n<!-- more -->\n\n## 原理\n---\n\n先来定义一些东西（`S，原串；P，匹配串；‘|’匹配成功；‘#’匹配失败`）\n\nHorspool看是否匹配时是从后往前扫描的，若全部匹配，则找到一个可匹配的方案~~free话~~，若有一个不匹配，则当前方案不存在~~free话真多~~。这时就要分情况讨论了。\n\n情况一：\n\n在下例情况中，称S中的‘d’为关键字符，就是P最后一个字符在S中的匹配字符。若P中除尾字符外没有与关键字符相同的字符，~~显然~~应该将P向后推len(P)个位置。\n\n```\nS - *****bcd*******\n         #||\nP -  2333acd\n  -->       2333acd\n```\n\n情况二：\n\n若P中除尾字符外有与关键字符相同的字符，~~显然~~应该将P向后推到P中最靠右的关键字符与S中的关键字符对齐。\n\n```\nS - *****bcd*******\n         #||\nP -  233dacd\n  -->   233dacd\n```\n自我感觉比BM好多了，简洁高效。\n\n\n\n## 代码\n---\n\n```C++\n//实现查找S中有多少个与P完全相同的子串 \n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar S[1000],P[1000];\nint ans,n,m;\nint* HorspoolTable(const char *P){  \n    int n = strlen(P);  \n    int* ht=new int[256];  //ht：Horspool的表，255为ASCII上限 \n    for (int i=0;i<256;i++)  ht[i]=n;//P中找不到这个字符就后移n位 \n    for (int i=0;i<n-1/*不包括P中的尾字符*/;i++)  ht[(int)P[i]]=n-i-1;  \n    return ht;  \n}  \nvoid Horspool(){  \n    int* ht=HorspoolTable(P);  \n    for(int i=0;i<=n-m;){  \n    \tint k=n-1;\n        for (k=m-1;k>=0&&S[i+k]==P[k];k--);  \n        if (k==-1)  ans++; //全部匹配，ans++ \n        i=i+ht[(int)S[i+m-1]]; //否则后移对应位数 \n    }  \n    delete []ht;  \n}  \nint main(){\n\tscanf(\"%s%s\",S,P);\n\tn=strlen(S);  \n    m=strlen(P);  \n\tHorspool();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n","tags":["字符串"],"categories":["算法"]},{"title":"用Hexo搭建自己的网站-写文章","url":"/用hexo搭建自己的网站-写文章.html","content":"\n如标题所述\n\n<!-- more -->\n\n在根目录下输入`hexo new \"title\"`命令，在source/_post/文件夹下会出现一个\"title.md\"\n\n打开然后就可以编辑了，语法是markdown。\n\n`<!-- more -->`用来分割梗概与正文。\n\n`categories `与` tags`分别是分类与标签，以tags为例语法是`tags: [tag1,tag2,tag3...tagn]`\n\n放个例子下来自己理解\n\n```markdown\n---\ntitle: example\ndate: 2018-05-01 16:32:31\ntags: [示例]\n---\n测试用页面\n<!-- more -->\n\n# 测试一\n\n---\n\n$E=mc^2$ \n\n​``` python\nimport pyqt\n​```\n\n~~删除线~~\n```\n\n","tags":["博客"],"categories":["blog"]},{"title":"用Hexo搭建自己的网站-环境配置","url":"/用hexo搭建自己的网站-环境配置.html","content":"\n介绍一下如何用hexo写自己的网站\n\n<!-- more -->\n\n细心的童鞋想必已经发现了我的博客右下角 ` hexo ` 字样，这其实就是我制作网站的工具。\n\n基本环境搭建步骤如下：\n\nnode.js -> Git -> hexo -> 测试运行\n\n# node\n---\n大家可以去[官网](https://nodejs.org/en/)下载，安装时无脑点确定即可~\n\n# Git\n---\n一样，去[官网](https://git-scm.com/download/win)下载，上面 `click here to download manually.` 按钮好像没用，点下面的选项下载。一样无脑确定\n\n# hexo\n---\n当前面都装好了后，打开cmd,键入`npm install -g hexo-cli `就完成了。\n\n# 创建你的第一个测试页面\n---\n\n## 初始化\n先随便创建一个文件夹，最好直接在磁盘下面，不要套在文件夹下面，不然以后可能会有意想不到的麻烦。`cd`到你创建的文件夹下，输入以下命令：\n```cmd\nhexo init  # hexo会在目标文件夹建立网站所需要的所有文件\nnpm install  # 安装依赖包\n```\n## 本地启动\n输入以下命令：\n```cmd\nhexo g # 等同于hexo generate，生成静态文件\nhexo s # 等同于hexo server，在本地服务器运行\n```\n之后打开浏览器并输入IP地址 http://localhost:4000/ 查看.\n如果出错了，在`cmd`中输入以下命令：\n```cmd\nhexo g\nhexo s -p 4001 # 用4001端口打开，而不是默认的4000\n```\n之后打开浏览器并输入IP地址 http://localhost:4001 查看.","tags":["博客"],"categories":["blog"]},{"title":"基础二分图的最大匹配问题","url":"/基础二分图的最大匹配问题.html","content":"\n​      标题已经说了，所以有基础的牛们就别想在这篇博客里看到什么有价值的东西。这里的解法是最基础的。\n\n> 二分图是一种可以把图中的点分为两个不同的集合，且同一集合中不存在任意两个有边联通的点（就算是单向边也不行）的图。\n\n<!-- more -->\n\n\n\n## 基本知识、概念\n\n---\n​       判断是否存在二分图有一个小技巧，如果有奇数条边的环，那么一定不存在二分图（因为这样就无法完美得分成两个集合）。至于最大匹配，就是选出尽量多的边，任意一个点只能与最多一条选中的的边相连。可以参照下面的图（a）。\n\n​       可能有人听说过“`完美匹配`”，就是说所有点都有在另一个集合中对应的点\n\n## 同类知识\n\n---\n​        二分图的最大匹配问题，与另一个同为网络流问题的最大流问题，都有一个“最大”，那么这之间是否有什么关系呢？答案是，真的有！那么现在先来了解一下有关最大流问题的的一些知识：https://zwestcow.github.io/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98Edmonds-Karp%E7%AE%97%E6%B3%95.html 。链接里的最大流用的也是基本解法。至于网络流是什么？也在链接里。\n\n​        之前说过二分图最大匹配与最大流有点关系，其实思索一下就会发现，人为主动的在图中添加一个s点与一个t点，然后将左边的点都与s点建立一条权值为1的边，右边的点都与t点建立一条权值为1的边，且所有边都改成从左集合到右集合的有向边，原本图（a）的二分图这就成了图（b），一道经典的最大流问题。 \n\n![](http://t1.aixinxi.net/o_1ccqp1cem1pvj19p11tf1or410i4a.png-w.jpg)\n\n\n\n## 优化\n\n---\n\n​    但是由于多增了n条边，复杂度也上去了不少，所以我们就要进行一些优化。\n\n​    我们可以对增广路稍稍做点修改，但是本质还是一样的。从左开始遍历时按照`【遍历了（左→右）-没遍历（右←左）-遍历了（左→右）-……】`这个模式走奇数步（这样终点才会在右边的集合）。为什么可以这样优化哪？相信这个问题读者能自己想通，并不是很难。\n\n## 模板代码（DFS版）\n\n---\n\n``` c++\n#include<iostream>\n#include<cstring>\n#include<cstdio> \n#include<algorithm>\n#define max 505  \nusing namespace std;  \nint map[max][max],p[max],m,n,k,ans; //存储图 ,邻接矩阵，p数组记录集合2中的点所匹配的点的编号   \nbool vis[max]; //记录集合2中的每个点是否被搜索过  \nint read(){\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn  ret*f;\n}\nbool DFS(int x)  {  \n    for(int i=1;i<=m;i++)  {  \n        if(map[x][i]&&!vis[i]/*保证一个节点只经过一次*/)  {  \n            vis[i]=1;  \n            if(p[i]==0||DFS(p[i])){  \n                p[i]=x;  \n                return 1;  \n            }  \n        }  \n    }  \n    return 0;  \n}    \nvoid getanswer()  {  \n    for(int i=1;i<=n;i++) {  \n        memset(vis,0,sizeof(vis));//清空上次搜索留下的痕迹 ,以找长度大于1的增广路  \n        if(DFS(i)) ans++;  //找到增广路，答案就加一 \n    }\n    return;\n}  \nint main() {  \n    freopen(\"ls.in\",\"r\",stdin);  \n    memset(map,0,sizeof(map));  \n    memset(p,0,sizeof(p));  \n    n=read();m=read();k=read();//A、B集合元素的个数 \n    for(int i=1;i<=k;i++){\n    \tint x=read(),y=read();\n    \tmap[x][y]=1;//有向路 \n\t}\n    getanswer();  \n    if(!ans) printf(\"No Solution!\\n\");\n    else printf(\"%d\\n\",ans);\n    return 0;  \n}  \n```\n\n\n\n\n\n## 练习题\n\n​    附上一道二分图匹配的模板题：Poj3041 <http://poj.org/problem?id=3041> \n\n### 题目大意\n\n（大部分翻译来自google，所以看不懂中文是正常的） [手动滑稽]：\n\n#### 标题\n\n​                                                                                          **小行星**\n\n---\n\n| 时间限制： 1000MS | 内存限制： 65536K |\n| ----------------- | ----------------- |\n| 提交总数： 25001  | 通过： 13523      |\n\n####  描述\n\n贝茜希望通过一个N×N网格（1 <= N <= 500）形状的危险小行星带来驾驶她的飞船。网格包含K个小行星（1 <= K <= 10,000），它们位于网格的格点处。 \n幸运的是，贝茜拥有一个强大的武器，可以消除任意一行或一列中的所有小行星。这种武器非常昂贵，所以她希望少用一些。给定所有小行星的位置，输出贝茜需要射击以消除所有小行星的最少射击次数。\n\n#### 输入\n\n* 第1行：两个整数N和K，由一个空格隔开。 \n* 第2行... K + 1行：每行包含两个空格分隔的整数R和C（1 <= R，C <= N），分别表示小行星的行坐标和列坐标。\n\n#### 产量\n\n* 第1行：表示贝茜必须射击的最少次数的整数。\n\n#### 示例输入\n\n```\n3 4\n1 1\n1 3\n2 2\n3 2\n```\n\n#### 示例输出\n\n```\n2\n```\n\n#### 暗示\n\n输入详细信息： \n下图表示数据，其中“X”是小行星和“.”是空的格子： \n`X.X .X. .X.` \n\n#### 输出细节\n\n贝西可能在第1排开火，破坏（1,1）和（1,3）处的小行星，然后她可能击落第2列以破坏（2,2）和（3,2）处的小行星。 \n\n### 题解\n\n​        我说过是模板题了。。。\n\n\n\n感谢《算法竞赛_入门经典》的图\n\n\n\n\n\n","tags":["网络流"],"categories":["算法"]},{"title":"最大流问题Edmonds-Karp算法","url":"/最大流问题Edmonds-Karp算法.html","content":"\n   实现最大流有好几种算法，比如Dinic或者ISAP算法，Edmonds-Karp只是其中最好理解的一种算法，它的实现要运用到增广路与BFS，当然也可以用DFS，但效率太低。网络流这东西是用来求从s点到t点（起点为s，终点为t）的流量问题，因为类似网络数据传输，所以叫做网络流。\n\n<!-- more -->\n### 知识点\n---\n>最大流说简单点就是使从s到t的流量最大。这玩意儿需要注意几个事实（起点为s,终点为t）：\n**每条边都有容量，当前的流量不可以超过流量；从s出来的流量等于流入t的流量；一般情况下点的容量是无限大的；s点与t点的容量无限大**\n\n有些东西就简写一下，待会看得懂就行：\n\n1. 容量（c），每条边最大运输量。\n\n2. 流量（f），当前用了的运输量。\n\n3. 残量网络，即每一条路上容量与流量之差，必须为正数， **若a->b的c为16，f为10 ，在残量网络中a->b为6还有一条边，b->a为10，有两条边！** 因为可以当做b->a为容量0，流量-11。例如图（a）的残量网络为图（b）。（前一个数为流量，后一个数为容量）\n\n![](http://t1.aixinxi.net/o_1ccqp1cem1pvj19p11tf1or410i4a.png-w.jpg)\n\n4. 增广路，每次在图中找到一条满足上述基本事实的一条从s到t的路（这里用BFS找），这条路上贡献的流量就是其最小残量，每次找到一条路，就让答案加上最小残量，当没有增广路时，可以证明答案即为最优。\n\n### 上代码\n---\n``` c++\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#define maxn 1005\n#define INF 2147483647\nusing namespace std;\nint read(){\n\tint ret=0,f=1;char  ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn ret*f;\n}\nstruct Edge{//用来维护每条边的信息 \n\tint from,to,cap,flow;\n\tEdge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){}\n};\nstruct EdmondsKarp{\n\tint n,m,s,t;//n:点数，m:边数，s:起点,t:终点 \n\tvector<Edge> edges;//边数开两倍（还有反向网络），这里偷一下懒 \n\tvector<int> G[maxn];//领接表，G[i][j]表示点i到延伸出去的第j条边在edges中的位置 \n\tint a[maxn];//最小残量，用以增广 \n\tint p[maxn];//p[i]表示到达节点i的那条边的编号，因为每次增广只增广一条路径，所以不用开二维 \n\tvoid init(){//不多说，初始化 \n\t\tn=read();m=read();s=read();t=read();\n\t\tfor(int i=0;i<n;i++) G[i].clear();\n\t\tedges.clear();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint from=read(),to=read(),cap=read();\n\t\t\tedges.push_back(Edge(from,to,cap,0));\n\t\t\tedges.push_back(Edge(to,from,0,0));//反向网络 \n\t\t\tint k=edges.size();\n\t\t\tG[from].push_back(k-2);\n\t\t\tG[from].push_back(k-1);  \n\t\t}\n\t}\n\tint Maxflow(){\n\t\tint ret=0;\n\t\twhile(1){\n\t\t\tmemset(a,0,sizeof(a));\n\t\t\tqueue<int> Q;//先进先出的队列 \n\t\t\tQ.push(s);\n\t\t\ta[s]=INF;\n\t\t\twhile(!Q.empty()){//里面就是在BFS \n\t\t\t\tint x=Q.front();//取队首 \n\t\t\t\tQ.pop();\n\t\t\t\tfor(int i=0;i<G[x].size();i++){\n\t\t\t\t\tEdge& e=edges[G[x][i]];\n\t\t\t\t\tif(!a[e.to]/*判环*/&&e.cap>e.flow){\n\t\t\t\t\t\tp[e.to]=G[x][i];//记住回去的路 \n\t\t\t\t\t\ta[e.to]=min(a[x],e.cap-e.flow);//去最小残量 \n\t\t\t\t\t\tQ.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[t]) break;//此条路已到达t \n\t\t\t} \n\t\t\tif(!a[t]) break;//没有增广路时，即为最大流 \n\t\t\tfor(int u=t;u!=s;u=edges[p[u]].from){//借助p数组倒回去给此次找到的增广路上的每条路的流量都加上最小残量a[t] \n\t\t\t\tedges[p[u]].flow+=a[t];\n\t\t\t\tedges[p[u]^1].flow-=a[t];//反向网络也要减掉a[t] \n\t\t\t}\n\t\t\tret+=a[t];//答案加上最小残量a[t] \n\t\t}\n\t\treturn ret;\n\t}\n}ans;\nint main(){\n\tfreopen(\"ls.in\",\"r\",stdin);\n\tans.init();\n\tprintf(\"%d\",ans.Maxflow());\n\treturn 0;\n}\n```\n如有不正之处，欢迎神犇们来喷。 若要未经博主允许随意转载请随便。","tags":["网络流"],"categories":["算法"]},{"title":"Example","url":"/example.html","content":"测试用页面\n<!-- more -->\n\n# 测试一\n\n---\n\n$E=mc^2$ \n\n``` python\nimport pyqt\n```\n\n~~删除线~~","tags":["示例"]},{"title":"Hello World","url":"/hello-world.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["示例"]}]