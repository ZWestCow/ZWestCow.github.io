[{"title":"基础二分图的最大匹配问题","url":"/基础二分图的最大匹配问题.html","content":"\n​      标题已经说了，所以有基础的牛们就别想在这篇博客里看到什么有价值的东西。这里的解法是最基础的。\n\n> 二分图是一种可以把图中的点分为两个不同的集合，且同一集合中不存在任意两个有边联通的点（就算是单向边也不行）的图。\n\n<!-- more -->\n\n\n\n## 基本知识、概念\n\n---\n​       判断是否存在二分图有一个小技巧，如果有奇数条边的环，那么一定不存在二分图（因为这样就无法完美得分成两个集合）。至于最大匹配，就是选出尽量多的边，任意一个点只能与最多一条选中的的边相连。可以参照下面的图（a）。\n\n​       可能有人听说过“`完美匹配`”，就是说所有点都有在另一个集合中对应的点\n\n## 同类知识\n\n---\n​        二分图的最大匹配问题，与另一个同为网络流问题的最大流问题，都有一个“最大”，那么这之间是否有什么关系呢？答案是，真的有！那么现在先来了解一下有关最大流问题的的一些知识：https://zwestcow.github.io/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98Edmonds-Karp%E7%AE%97%E6%B3%95.html 。链接里的最大流用的也是基本解法。至于网络流是什么？也在链接里。\n\n​        之前说过二分图最大匹配与最大流有点关系，其实思索一下就会发现，人为主动的在图中添加一个s点与一个t点，然后将左边的点都与s点建立一条权值为1的边，右边的点都与t点建立一条权值为1的边，且所有边都改成从左集合到右集合的有向边，原本图（a）的二分图这就成了图（b），一道经典的最大流问题。 \n\n![](http://t1.aixinxi.net/o_1ccqp1cem1pvj19p11tf1or410i4a.png-w.jpg)\n\n\n\n## 优化\n\n---\n\n​    但是由于多增了n条边，复杂度也上去了不少，所以我们就要进行一些优化。\n\n​    我们可以对增广路稍稍做点修改，但是本质还是一样的。从左开始遍历时按照`【遍历了（左→右）-没遍历（右←左）-遍历了（左→右）-……】`这个模式走奇数步（这样终点才会在右边的集合）。为什么可以这样优化哪？相信这个问题读者能自己想通，并不是很难。\n\n## 模板代码（DFS版）\n\n---\n\n``` c++\n#include<iostream>\n#include<cstring>\n#include<cstdio> \n#include<algorithm>\n#define max 505  \nusing namespace std;  \nint map[max][max],p[max],m,n,k,ans; //存储图 ,邻接矩阵，p数组记录集合2中的点所匹配的点的编号   \nbool vis[max]; //记录集合2中的每个点是否被搜索过  \nint read(){\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn  ret*f;\n}\nbool DFS(int x)  {  \n    for(int i=1;i<=m;i++)  {  \n        if(map[x][i]&&!vis[i]/*保证一个节点只经过一次*/)  {  \n            vis[i]=1;  \n            if(p[i]==0||DFS(p[i])){  \n                p[i]=x;  \n                return 1;  \n            }  \n        }  \n    }  \n    return 0;  \n}    \nvoid getanswer()  {  \n    for(int i=1;i<=n;i++) {  \n        memset(vis,0,sizeof(vis));//清空上次搜索留下的痕迹 ,以找长度大于1的增广路  \n        if(DFS(i)) ans++;  //找到增广路，答案就加一 \n    }\n    return;\n}  \nint main() {  \n    freopen(\"ls.in\",\"r\",stdin);  \n    memset(map,0,sizeof(map));  \n    memset(p,0,sizeof(p));  \n    n=read();m=read();k=read();//A、B集合元素的个数 \n    for(int i=1;i<=k;i++){\n    \tint x=read(),y=read();\n    \tmap[x][y]=1;//有向路 \n\t}\n    getanswer();  \n    if(!ans) printf(\"No Solution!\\n\");\n    else printf(\"%d\\n\",ans);\n    return 0;  \n}  \n```\n\n\n\n\n\n## 练习题\n\n​    附上一道二分图匹配的模板题：Poj3041 <http://poj.org/problem?id=3041> \n\n### 题目大意\n\n（大部分翻译来自google，所以看不懂中文是正常的） [手动滑稽]：\n\n#### 标题\n\n​                                                                                          **小行星**\n\n---\n\n| 时间限制： 1000MS | 内存限制： 65536K |\n| ----------------- | ----------------- |\n| 提交总数： 25001  | 通过： 13523      |\n\n####  描述\n\n贝茜希望通过一个N×N网格（1 <= N <= 500）形状的危险小行星带来驾驶她的飞船。网格包含K个小行星（1 <= K <= 10,000），它们位于网格的格点处。 \n幸运的是，贝茜拥有一个强大的武器，可以消除任意一行或一列中的所有小行星。这种武器非常昂贵，所以她希望少用一些。给定所有小行星的位置，输出贝茜需要射击以消除所有小行星的最少射击次数。\n\n#### 输入\n\n* 第1行：两个整数N和K，由一个空格隔开。 \n* 第2行... K + 1行：每行包含两个空格分隔的整数R和C（1 <= R，C <= N），分别表示小行星的行坐标和列坐标。\n\n#### 产量\n\n* 第1行：表示贝茜必须射击的最少次数的整数。\n\n#### 示例输入\n\n```\n3 4\n1 1\n1 3\n2 2\n3 2\n```\n\n#### 示例输出\n\n```\n2\n```\n\n#### 暗示\n\n输入详细信息： \n下图表示数据，其中“X”是小行星和“.”是空的格子： \n`X.X .X. .X.` \n\n#### 输出细节\n\n贝西可能在第1排开火，破坏（1,1）和（1,3）处的小行星，然后她可能击落第2列以破坏（2,2）和（3,2）处的小行星。 \n\n### 题解\n\n​        我说过是模板题了。。。\n\n\n\n感谢《算法竞赛_入门经典》的图\n\n\n\n\n\n","tags":["网络流"],"categories":["算法"]},{"title":"最大流问题Edmonds-Karp算法","url":"/最大流问题Edmonds-Karp算法.html","content":"\n   实现最大流有好几种算法，比如Dinic或者ISAP算法，Edmonds-Karp只是其中最好理解的一种算法，它的实现要运用到增广路与BFS，当然也可以用DFS，但效率太低。网络流这东西是用来求从s点到t点（起点为s，终点为t）的流量问题，因为类似网络数据传输，所以叫做网络流。\n\n<!-- more -->\n### 知识点\n---\n>最大流说简单点就是使从s到t的流量最大。这玩意儿需要注意几个事实（起点为s,终点为t）：\n**每条边都有容量，当前的流量不可以超过流量；从s出来的流量等于流入t的流量；一般情况下点的容量是无限大的；s点与t点的容量无限大**\n\n有些东西就简写一下，待会看得懂就行：\n\n1. 容量（c），每条边最大运输量。\n\n2. 流量（f），当前用了的运输量。\n\n3. 残量网络，即每一条路上容量与流量之差，必须为正数， **若a->b的c为16，f为10 ，在残量网络中a->b为6还有一条边，b->a为10，有两条边！** 因为可以当做b->a为容量0，流量-11。例如图（a）的残量网络为图（b）。（前一个数为流量，后一个数为容量）\n\n![](http://t1.aixinxi.net/o_1ccqp1cem1pvj19p11tf1or410i4a.png-w.jpg)\n\n4. 增广路，每次在图中找到一条满足上述基本事实的一条从s到t的路（这里用BFS找），这条路上贡献的流量就是其最小残量，每次找到一条路，就让答案加上最小残量，当没有增广路时，可以证明答案即为最优。\n\n### 上代码\n---\n``` c++\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#define maxn 1005\n#define INF 2147483647\nusing namespace std;\nint read(){\n\tint ret=0,f=1;char  ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn ret*f;\n}\nstruct Edge{//用来维护每条边的信息 \n\tint from,to,cap,flow;\n\tEdge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){}\n};\nstruct EdmondsKarp{\n\tint n,m,s,t;//n:点数，m:边数，s:起点,t:终点 \n\tvector<Edge> edges;//边数开两倍（还有反向网络），这里偷一下懒 \n\tvector<int> G[maxn];//领接表，G[i][j]表示点i到延伸出去的第j条边在edges中的位置 \n\tint a[maxn];//最小残量，用以增广 \n\tint p[maxn];//p[i]表示到达节点i的那条边的编号，因为每次增广只增广一条路径，所以不用开二维 \n\tvoid init(){//不多说，初始化 \n\t\tn=read();m=read();s=read();t=read();\n\t\tfor(int i=0;i<n;i++) G[i].clear();\n\t\tedges.clear();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint from=read(),to=read(),cap=read();\n\t\t\tedges.push_back(Edge(from,to,cap,0));\n\t\t\tedges.push_back(Edge(to,from,0,0));//反向网络 \n\t\t\tint k=edges.size();\n\t\t\tG[from].push_back(k-2);\n\t\t\tG[from].push_back(k-1);  \n\t\t}\n\t}\n\tint Maxflow(){\n\t\tint ret=0;\n\t\twhile(1){\n\t\t\tmemset(a,0,sizeof(a));\n\t\t\tqueue<int> Q;//先进先出的队列 \n\t\t\tQ.push(s);\n\t\t\ta[s]=INF;\n\t\t\twhile(!Q.empty()){//里面就是在BFS \n\t\t\t\tint x=Q.front();//取队首 \n\t\t\t\tQ.pop();\n\t\t\t\tfor(int i=0;i<G[x].size();i++){\n\t\t\t\t\tEdge& e=edges[G[x][i]];\n\t\t\t\t\tif(!a[e.to]/*判环*/&&e.cap>e.flow){\n\t\t\t\t\t\tp[e.to]=G[x][i];//记住回去的路 \n\t\t\t\t\t\ta[e.to]=min(a[x],e.cap-e.flow);//去最小残量 \n\t\t\t\t\t\tQ.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[t]) break;//此条路已到达t \n\t\t\t} \n\t\t\tif(!a[t]) break;//没有增广路时，即为最大流 \n\t\t\tfor(int u=t;u!=s;u=edges[p[u]].from){//借助p数组倒回去给此次找到的增广路上的每条路的流量都加上最小残量a[t] \n\t\t\t\tedges[p[u]].flow+=a[t];\n\t\t\t\tedges[p[u]^1].flow-=a[t];//反向网络也要减掉a[t] \n\t\t\t}\n\t\t\tret+=a[t];//答案加上最小残量a[t] \n\t\t}\n\t\treturn ret;\n\t}\n}ans;\nint main(){\n\tfreopen(\"ls.in\",\"r\",stdin);\n\tans.init();\n\tprintf(\"%d\",ans.Maxflow());\n\treturn 0;\n}\n```\n如有不正之处，欢迎神犇们来喷。 若要未经博主允许随意转载请随便。","tags":["网络流"],"categories":["算法"]},{"title":"Example","url":"/example.html","content":"测试用页面\n<!-- more -->\n\n# 测试一\n\n---\n\n$E=mc^2$ \n\n``` python\nimport pyqt\n```\n\n~~删除线~~","tags":["示例"]},{"title":"Hello World","url":"/hello-world.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["示例"]}]