[{"title":"高效的单字符串匹配算法Horspool","url":"/高效的单字符串匹配算法Horspool.html","content":"\n在单字符串匹配算法的领域中，有两种为人熟知的算法：KMP（~~看毛片~~）和BM算法，这两种算法虽然经典，不过难码。实际上许多简单的算法速度也是飞快。于是就让我们来认识一下BM的简化版——Horspool，效率比KMP、BM都快，还好理解。\n\n<!-- more -->\n\n## 原理\n---\n\n先来定义一些东西（`S，原串；P，匹配串；‘|’匹配成功；‘#’匹配失败`）\n\nHorspool看是否匹配时是从后往前扫描的，若全部匹配，则找到一个可匹配的方案~~free话~~，若有一个不匹配，则当前方案不存在~~free话真多~~。这时就要分情况讨论了。\n\n情况一：\n\n在下例情况中，称S中的‘d’为关键字符，就是P最后一个字符在S中的匹配字符。若P中除尾字符外没有与关键字符相同的字符，~~显然~~应该将P向后推len(P)个位置。\n\n```\nS - *****bcd*******\n         #||\nP -  2333acd\n  -->       2333acd\n```\n\n情况二：\n\n若P中除尾字符外有与关键字符相同的字符，~~显然~~应该将P向后推到P中最靠右的关键字符与S中的关键字符对齐。\n\n```\nS - *****bcd*******\n         #||\nP -  233dacd\n  -->   233dacd\n```\n自我感觉比BM好多了，简洁高效。\n\n\n\n## 代码\n---\n\n```C++\n//实现查找S中有多少个与P完全相同的子串 \n#include<cstdio>\n#include<cstring>\nusing namespace std;\nchar S[1000],P[1000];\nint ans,n,m;\nint* HorspoolTable(const char *P){  \n    int n = strlen(P);  \n    int* ht=new int[256];  //ht：Horspool的表，255为ASCII上限 \n    for (int i=0;i<256;i++)  ht[i]=n;//P中找不到这个字符就后移n位 \n    for (int i=0;i<n-1/*不包括P中的尾字符*/;i++)  ht[(int)P[i]]=n-i-1;  \n    return ht;  \n}  \nvoid Horspool(){  \n    int* ht=HorspoolTable(P);  \n    for(int i=0;i<=n-m;){  \n    \tint k=n-1;\n        for (k=m-1;k>=0&&S[i+k]==P[k];k--);  \n        if (k==-1)  ans++; //全部匹配，ans++ \n        i=i+ht[(int)S[i+m-1]]; //否则后移对应位数 \n    }  \n    delete []ht;  \n}  \nint main(){\n\tscanf(\"%s%s\",S,P);\n\tn=strlen(S);  \n    m=strlen(P);  \n\tHorspool();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n","tags":["字符串"],"categories":["算法"]},{"title":"用Hexo搭建自己的网站-写文章","url":"/用hexo搭建自己的网站-写文章.html","content":"\n如标题所述\n\n<!-- more -->\n\n在根目录下输入`hexo new \"title\"`命令，在source/_post/文件夹下会出现一个\"title.md\"\n\n打开然后就可以编辑了，语法是markdown。\n\n`<!-- more -->`用来分割梗概与正文。\n\n`categories `与` tags`分别是分类与标签，以tags为例语法是`tags: [tag1,tag2,tag3...tagn]`\n\n放个例子下来自己理解\n\n```markdown\n---\ntitle: example\ndate: 2018-05-01 16:32:31\ntags: [示例]\n---\n测试用页面\n<!-- more -->\n\n# 测试一\n\n---\n\n$E=mc^2$ \n\n​``` python\nimport pyqt\n​```\n\n~~删除线~~\n```\n\n","tags":["博客"],"categories":["blog"]},{"title":"用Hexo搭建自己的网站-环境配置","url":"/用hexo搭建自己的网站-环境配置.html","content":"\n介绍一下如何用hexo写自己的网站\n\n<!-- more -->\n\n细心的童鞋想必已经发现了我的博客右下角 ` hexo ` 字样，这其实就是我制作网站的工具。\n\n基本环境搭建步骤如下：\n\nnode.js -> Git -> hexo -> 测试运行\n\n# node\n---\n大家可以去[官网](https://nodejs.org/en/)下载，安装时无脑点确定即可~\n\n# Git\n---\n一样，去[官网](https://git-scm.com/download/win)下载，上面 `click here to download manually.` 按钮好像没用，点下面的选项下载。一样无脑确定\n\n# hexo\n---\n当前面都装好了后，打开cmd,键入`npm install -g hexo-cli `就完成了。\n\n# 创建你的第一个测试页面\n---\n\n## 初始化\n先随便创建一个文件夹，最好直接在磁盘下面，不要套在文件夹下面，不然以后可能会有意想不到的麻烦。`cd`到你创建的文件夹下，输入以下命令：\n```cmd\nhexo init  # hexo会在目标文件夹建立网站所需要的所有文件\nnpm install  # 安装依赖包\n```\n## 本地启动\n输入以下命令：\n```cmd\nhexo g # 等同于hexo generate，生成静态文件\nhexo s # 等同于hexo server，在本地服务器运行\n```\n之后打开浏览器并输入IP地址 http://localhost:4000/ 查看.\n如果出错了，在`cmd`中输入以下命令：\n```cmd\nhexo g\nhexo s -p 4001 # 用4001端口打开，而不是默认的4000\n```\n之后打开浏览器并输入IP地址 http://localhost:4001 查看.","tags":["博客"],"categories":["blog"]},{"title":"基础二分图的最大匹配问题","url":"/基础二分图的最大匹配问题.html","content":"\n​      标题已经说了，所以有基础的牛们就别想在这篇博客里看到什么有价值的东西。这里的解法是最基础的。\n\n> 二分图是一种可以把图中的点分为两个不同的集合，且同一集合中不存在任意两个有边联通的点（就算是单向边也不行）的图。\n\n<!-- more -->\n\n\n\n## 基本知识、概念\n\n---\n​       判断是否存在二分图有一个小技巧，如果有奇数条边的环，那么一定不存在二分图（因为这样就无法完美得分成两个集合）。至于最大匹配，就是选出尽量多的边，任意一个点只能与最多一条选中的的边相连。可以参照下面的图（a）。\n\n​       可能有人听说过“`完美匹配`”，就是说所有点都有在另一个集合中对应的点\n\n## 同类知识\n\n---\n​        二分图的最大匹配问题，与另一个同为网络流问题的最大流问题，都有一个“最大”，那么这之间是否有什么关系呢？答案是，真的有！那么现在先来了解一下有关最大流问题的的一些知识：https://zwestcow.github.io/%E6%9C%80%E5%A4%A7%E6%B5%81%E9%97%AE%E9%A2%98Edmonds-Karp%E7%AE%97%E6%B3%95.html 。链接里的最大流用的也是基本解法。至于网络流是什么？也在链接里。\n\n​        之前说过二分图最大匹配与最大流有点关系，其实思索一下就会发现，人为主动的在图中添加一个s点与一个t点，然后将左边的点都与s点建立一条权值为1的边，右边的点都与t点建立一条权值为1的边，且所有边都改成从左集合到右集合的有向边，原本图（a）的二分图这就成了图（b），一道经典的最大流问题。 \n\n![](http://t1.aixinxi.net/o_1ccqp1cem1pvj19p11tf1or410i4a.png-w.jpg)\n\n\n\n## 优化\n\n---\n\n​    但是由于多增了n条边，复杂度也上去了不少，所以我们就要进行一些优化。\n\n​    我们可以对增广路稍稍做点修改，但是本质还是一样的。从左开始遍历时按照`【遍历了（左→右）-没遍历（右←左）-遍历了（左→右）-……】`这个模式走奇数步（这样终点才会在右边的集合）。为什么可以这样优化哪？相信这个问题读者能自己想通，并不是很难。\n\n## 模板代码（DFS版）\n\n---\n\n``` c++\n#include<iostream>\n#include<cstring>\n#include<cstdio> \n#include<algorithm>\n#define max 505  \nusing namespace std;  \nint map[max][max],p[max],m,n,k,ans; //存储图 ,邻接矩阵，p数组记录集合2中的点所匹配的点的编号   \nbool vis[max]; //记录集合2中的每个点是否被搜索过  \nint read(){\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn  ret*f;\n}\nbool DFS(int x)  {  \n    for(int i=1;i<=m;i++)  {  \n        if(map[x][i]&&!vis[i]/*保证一个节点只经过一次*/)  {  \n            vis[i]=1;  \n            if(p[i]==0||DFS(p[i])){  \n                p[i]=x;  \n                return 1;  \n            }  \n        }  \n    }  \n    return 0;  \n}    \nvoid getanswer()  {  \n    for(int i=1;i<=n;i++) {  \n        memset(vis,0,sizeof(vis));//清空上次搜索留下的痕迹 ,以找长度大于1的增广路  \n        if(DFS(i)) ans++;  //找到增广路，答案就加一 \n    }\n    return;\n}  \nint main() {  \n    freopen(\"ls.in\",\"r\",stdin);  \n    memset(map,0,sizeof(map));  \n    memset(p,0,sizeof(p));  \n    n=read();m=read();k=read();//A、B集合元素的个数 \n    for(int i=1;i<=k;i++){\n    \tint x=read(),y=read();\n    \tmap[x][y]=1;//有向路 \n\t}\n    getanswer();  \n    if(!ans) printf(\"No Solution!\\n\");\n    else printf(\"%d\\n\",ans);\n    return 0;  \n}  \n```\n\n\n\n\n\n## 练习题\n\n​    附上一道二分图匹配的模板题：Poj3041 <http://poj.org/problem?id=3041> \n\n### 题目大意\n\n（大部分翻译来自google，所以看不懂中文是正常的） [手动滑稽]：\n\n#### 标题\n\n​                                                                                          **小行星**\n\n---\n\n| 时间限制： 1000MS | 内存限制： 65536K |\n| ----------------- | ----------------- |\n| 提交总数： 25001  | 通过： 13523      |\n\n####  描述\n\n贝茜希望通过一个N×N网格（1 <= N <= 500）形状的危险小行星带来驾驶她的飞船。网格包含K个小行星（1 <= K <= 10,000），它们位于网格的格点处。 \n幸运的是，贝茜拥有一个强大的武器，可以消除任意一行或一列中的所有小行星。这种武器非常昂贵，所以她希望少用一些。给定所有小行星的位置，输出贝茜需要射击以消除所有小行星的最少射击次数。\n\n#### 输入\n\n* 第1行：两个整数N和K，由一个空格隔开。 \n* 第2行... K + 1行：每行包含两个空格分隔的整数R和C（1 <= R，C <= N），分别表示小行星的行坐标和列坐标。\n\n#### 产量\n\n* 第1行：表示贝茜必须射击的最少次数的整数。\n\n#### 示例输入\n\n```\n3 4\n1 1\n1 3\n2 2\n3 2\n```\n\n#### 示例输出\n\n```\n2\n```\n\n#### 暗示\n\n输入详细信息： \n下图表示数据，其中“X”是小行星和“.”是空的格子： \n`X.X .X. .X.` \n\n#### 输出细节\n\n贝西可能在第1排开火，破坏（1,1）和（1,3）处的小行星，然后她可能击落第2列以破坏（2,2）和（3,2）处的小行星。 \n\n### 题解\n\n​        我说过是模板题了。。。\n\n\n\n感谢《算法竞赛_入门经典》的图\n\n\n\n\n\n","tags":["网络流"],"categories":["算法"]},{"title":"最大流问题Edmonds-Karp算法","url":"/最大流问题Edmonds-Karp算法.html","content":"\n   实现最大流有好几种算法，比如Dinic或者ISAP算法，Edmonds-Karp只是其中最好理解的一种算法，它的实现要运用到增广路与BFS，当然也可以用DFS，但效率太低。网络流这东西是用来求从s点到t点（起点为s，终点为t）的流量问题，因为类似网络数据传输，所以叫做网络流。\n\n<!-- more -->\n### 知识点\n---\n>最大流说简单点就是使从s到t的流量最大。这玩意儿需要注意几个事实（起点为s,终点为t）：\n**每条边都有容量，当前的流量不可以超过流量；从s出来的流量等于流入t的流量；一般情况下点的容量是无限大的；s点与t点的容量无限大**\n\n有些东西就简写一下，待会看得懂就行：\n\n1. 容量（c），每条边最大运输量。\n\n2. 流量（f），当前用了的运输量。\n\n3. 残量网络，即每一条路上容量与流量之差，必须为正数， **若a->b的c为16，f为10 ，在残量网络中a->b为6还有一条边，b->a为10，有两条边！** 因为可以当做b->a为容量0，流量-11。例如图（a）的残量网络为图（b）。（前一个数为流量，后一个数为容量）\n\n![](http://t1.aixinxi.net/o_1ccqp1cem1pvj19p11tf1or410i4a.png-w.jpg)\n\n4. 增广路，每次在图中找到一条满足上述基本事实的一条从s到t的路（这里用BFS找），这条路上贡献的流量就是其最小残量，每次找到一条路，就让答案加上最小残量，当没有增广路时，可以证明答案即为最优。\n\n### 上代码\n---\n``` c++\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#define maxn 1005\n#define INF 2147483647\nusing namespace std;\nint read(){\n\tint ret=0,f=1;char  ch=getchar();\n\twhile(ch<'0'||ch>'9') {if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn ret*f;\n}\nstruct Edge{//用来维护每条边的信息 \n\tint from,to,cap,flow;\n\tEdge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){}\n};\nstruct EdmondsKarp{\n\tint n,m,s,t;//n:点数，m:边数，s:起点,t:终点 \n\tvector<Edge> edges;//边数开两倍（还有反向网络），这里偷一下懒 \n\tvector<int> G[maxn];//领接表，G[i][j]表示点i到延伸出去的第j条边在edges中的位置 \n\tint a[maxn];//最小残量，用以增广 \n\tint p[maxn];//p[i]表示到达节点i的那条边的编号，因为每次增广只增广一条路径，所以不用开二维 \n\tvoid init(){//不多说，初始化 \n\t\tn=read();m=read();s=read();t=read();\n\t\tfor(int i=0;i<n;i++) G[i].clear();\n\t\tedges.clear();\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint from=read(),to=read(),cap=read();\n\t\t\tedges.push_back(Edge(from,to,cap,0));\n\t\t\tedges.push_back(Edge(to,from,0,0));//反向网络 \n\t\t\tint k=edges.size();\n\t\t\tG[from].push_back(k-2);\n\t\t\tG[from].push_back(k-1);  \n\t\t}\n\t}\n\tint Maxflow(){\n\t\tint ret=0;\n\t\twhile(1){\n\t\t\tmemset(a,0,sizeof(a));\n\t\t\tqueue<int> Q;//先进先出的队列 \n\t\t\tQ.push(s);\n\t\t\ta[s]=INF;\n\t\t\twhile(!Q.empty()){//里面就是在BFS \n\t\t\t\tint x=Q.front();//取队首 \n\t\t\t\tQ.pop();\n\t\t\t\tfor(int i=0;i<G[x].size();i++){\n\t\t\t\t\tEdge& e=edges[G[x][i]];\n\t\t\t\t\tif(!a[e.to]/*判环*/&&e.cap>e.flow){\n\t\t\t\t\t\tp[e.to]=G[x][i];//记住回去的路 \n\t\t\t\t\t\ta[e.to]=min(a[x],e.cap-e.flow);//去最小残量 \n\t\t\t\t\t\tQ.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[t]) break;//此条路已到达t \n\t\t\t} \n\t\t\tif(!a[t]) break;//没有增广路时，即为最大流 \n\t\t\tfor(int u=t;u!=s;u=edges[p[u]].from){//借助p数组倒回去给此次找到的增广路上的每条路的流量都加上最小残量a[t] \n\t\t\t\tedges[p[u]].flow+=a[t];\n\t\t\t\tedges[p[u]^1].flow-=a[t];//反向网络也要减掉a[t] \n\t\t\t}\n\t\t\tret+=a[t];//答案加上最小残量a[t] \n\t\t}\n\t\treturn ret;\n\t}\n}ans;\nint main(){\n\tfreopen(\"ls.in\",\"r\",stdin);\n\tans.init();\n\tprintf(\"%d\",ans.Maxflow());\n\treturn 0;\n}\n```\n如有不正之处，欢迎神犇们来喷。 若要未经博主允许随意转载请随便。","tags":["网络流"],"categories":["算法"]},{"title":"Example","url":"/example.html","content":"测试用页面\n<!-- more -->\n\n# 测试一\n\n---\n\n$E=mc^2$ \n\n``` python\nimport pyqt\n```\n\n~~删除线~~","tags":["示例"]},{"title":"Hello World","url":"/hello-world.html","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!-- more -->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["示例"]}]